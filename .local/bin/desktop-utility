#!/usr/bin/env python3
# Imports {{{
import signal
import os
from i3ipc import Connection, Event
import gbulb
import dbus
from dbus.mainloop.glib import DBusGMainLoop
from enum import Enum
import re
import Xlib.X
import Xlib.Xatom
import Xlib.display
# }}}
# Model {{{
class SignalHandler:
    def __init__(self):
        self._parent = None

    def register(self, ipc_grp):
        self.ipc_grp = ipc_grp

    def unregister(self):
        ...


#class MultiHandler(SignalHandler):
#    def __init__(self, init):
#        super().__init__()
#        init._parent = self
#        self.handlers = [init]
#
#    def register(self, ipc_grp):
#        super().register(ipc_grp)
#        for h in handlers:
#            h.ipc_grp = ipc_grp
#
#    def handler(self, *args, **kwargs):
#        for h in reversed(handlers):
#            h.handler(*args, **kwargs)
#
#    def push(self, handler):
#        handler._parent = self
#        handler.ipc_grp = self.ipc_grp
#        self.handlers.append(handler)
#
#    def pop(self):
#        handler = self.handlers.pop(-1)
#        handler._parent = None
#        handler.ipc_grp = None


DBusBus = Enum('DBusBus', ('SYSTEM', 'SESSION'))


class DBusSignalHandler(SignalHandler):
    def __init__(self):
        super().__init__()

    def register(self, ipc_grp):
        super().register(ipc_grp)
        if self.bus == DBusBus.SYSTEM:
            bus = ipc_grp.d_sys()
        elif self.bus == DBusBus.SESSION:
            bus = ipc_grp.d_ses()
        bus.add_signal_receiver(self.handler, **self.dbus_kwargs)


class i3SignalHandler(SignalHandler):
    def __init__(self):
        super().__init__()

    def register(self, ipc_grp):
        super().register(ipc_grp)
        ipc_grp.i3().on(self.event, self.handler)


#class i3MultiHandler(MultiHandler):
#    def __init__(self):
#        super().__init__()
#
#    def register(self, ipc_grp):
#        super().register(ipc_grp)
#        ipc_grp.i3().on(self.event, self.handler)


NOP_CMD_ARG = re.compile(r'.*nop ([^;, ]*) ?([^;,]*)(;|,|$)')


class i3BindHandler(i3SignalHandler):
    event = Event.BINDING
    def __init__(self):
        super().__init__()

    def handler(self, i3, e):
        if len(e.binding.command) > 4 and e.binding.command[0] == 'n' \
        and e.binding.command[1] == 'o' and e.binding.command[2] == 'p':
            if m := NOP_CMD_ARG.match(e.binding.command):
                cmd = m.groups()
                if f := getattr(self, cmd[0], None):
                    if len(cmd[1]) == 0:
                        f()
                    else:
                        f(*cmd[1].split(' '))


class IPCGroup:
    def __init__(self):
        self._i3 = None
        self._d_sys = None
        self._d_ses = None
        self._dpy = None

    def i3(self):
        if self._i3 is None:
            self._i3 = Connection()
        return self._i3

    def pre_loop(self, loop):
        self._loop = loop
        if self._i3:
            self._i3._event_socket_setup()
            loop.add_reader(self._i3._sub_socket, self._i3._event_socket_poll)

    def post_loop(self):
        if self._i3:
            self._i3._event_socket_teardown()
        if self._dpy:
            self._dpy.close()

    def d_sys(self):
        if self._d_sys is None:
            self._d_sys = dbus.SystemBus()
        return self._d_sys

    def d_ses(self):
        if self._d_ses is None:
            self._d_ses = dbus.SessionBus()
        return self._d_ses

    def dpy(self):
        if self._dpy is None:
            self._dpy = Xlib.display.Display()
        return self._dpy

    def quit(self):
        self._loop.stop()


class SignalHandlerGroup:
    def __init__(self, *handlers):
        self.handlers = handlers

    def register(self, ipc_grp):
        for handler in self.handlers:
            handler.register(ipc_grp)


class DesktopUtility:
    def __init__(self, sh_grp):
        self.sh_grp = sh_grp

    def run(self, loop):
        self._loop = loop
        self.ipc_grp = IPCGroup()
        self.sh_grp.register(self.ipc_grp)
        self.ipc_grp.pre_loop(loop)
        try:
            self._loop.run_forever()
        finally:
            self.ipc_grp.post_loop()
            self._loop.close()
# }}}
# Helper functions {{{
def find_ws(i3_ws, postfix=None, reverse=False):
    all_ws = {1,2,3,4,5,6,7,8,9,10}
    for ws in i3_ws:
        if postfix is not None and postfix in ws.name:
            return ws.name
        all_ws.discard(ws.num)
    if reverse:
        new_ws = str(max(all_ws))
    else:
        new_ws = str(min(all_ws))
    if postfix is not None:
        new_ws += ':' + postfix
    return new_ws


def skip_taskbar(display, windows):
    st = display.intern_atom('_NET_WM_STATE')
    sk = [display.intern_atom('_NET_WM_STATE_SKIP_TASKBAR')]
    for wid in windows:
        display.create_resource_object('window', wid).change_property(st,
                                                                      Xlib.Xatom.ATOM,
                                                                      32, sk,
                                                                      Xlib.X.PropModeReplace)
    display.flush()


def filter_floating(con):
    return con.floating == 'auto_on' or con.floating == 'user_on'
# }}}
# Handlers {{{
# Screensaver {{{
class ScreensaverHandler(DBusSignalHandler):
    def __init__(self):
        super().__init__()

    bus = DBusBus.SESSION
    dbus_kwargs = {'dbus_interface': 'org.mate.ScreenSaver'}

    def handler(self, state, *args, **kwargs):
        if state == 1:
            os.system('dunstctl set-paused true')
        elif state == 0:
            os.system('dunstctl set-paused false')
# }}}
# Special workspace {{{
class SpecialWorkspaceHandler(i3SignalHandler):
    def __init__(self):
        super().__init__()

    event = Event.WORKSPACE_FOCUS
    launchers = {
        'b': 'exec --no-startup-id exec $HOME/.i3/chatrc',
        'e': 'exec --no-startup-id exec $HOME/.i3/mailrc',
        'g': 'exec --no-startup-id exec $HOME/.i3/officerc',
        't': 'exec --no-startup-id exec $TERMINAL',
        'w': 'exec --no-startup-id exec $HOME/.i3/webrc',
        'y': 'exec --no-startup-id exec $HOME/.i3/mediarc',
        'z': 'exec --no-startup-id exec $HOME/.i3/gamerc'
    }

    def get_launcher(self, ws, override=False):
        if ws.name[0] in self.launchers:
            launcher = self.launchers[ws.name[0]]
            if override:
                return launcher
            for _ in ws:
                return None
            return launcher
        return None

    def handler(self, i3, e):
        if launcher := self.get_launcher(e.current):
            for ws in i3.get_workspaces():
                if ws.focused and ws.name != e.current.name:
                    return
            i3.command(launcher)
# }}}
# Keybindings {{{
class KeybindingsHandler(i3BindHandler):
    # Class {{{
    def __init__(self, special_ws):
        super().__init__()
        self.special_ws = special_ws

    def register(self, ipc_grp):
        super().register(ipc_grp)
        self.i3 = self.ipc_grp.i3()
    # }}}
    # Run launcher for current workspace {{{
    def launch_this(self):
        for ws in self.i3.get_workspaces():
            if ws.focused:
                if launcher := special_ws.get_launcher(ws, True):
                    self.i3.command(launcher)
                    break
    # }}}
    # Switch or move to blank workspace {{{
    def blank_ws(self, *args):
        reverse = len(args) > 0 and '--reverse' in args
        move = len(args) > 0 and '--move' in args
        new_ws = find_ws(self.i3.get_workspaces(), reverse=reverse)
        if move:
            self.i3.command(f'move container to workspace number {new_ws};workspace number {new_ws}')
        else:
            self.i3.command(f'workspace number {new_ws}')
    # }}}
    # Show/hide scratchpad window {{{
    scratch_focus_ids = {
        'calc': (lambda c: c.find_instanced(r'^scratch_calc$'),
                         'exec --no-startup-id timeout 30s $HOME/.local/lib/dotfiles/misc_scripts/launch $HOME/.local/lib/dotfiles/applications/scratch_calc'),
        'password_man': (lambda c: c.find_classed(r'^KeePassXC$'),
                      'exec --no-startup-id exec keepassxc'),
        'phone_control': (lambda c: c.find_instanced(r'^kdeconnect-app$'),
                      'exec --no-startup-id exec kdeconnect-app'),
        'scratch_term': (lambda c: c.find_instanced(r'^scratch_term$'),
                      'exec "exec mate-terminal --name scratch_term --disable-factory"'),
        'charmap': (lambda c: c.find_instanced(r'^gucharmap$'),
                      'exec exec gucharmap'),
        'timer': (lambda c: c.find_instanced(r'^org\.gnome\.clocks$'),
                      'exec --no-startup-id exec gnome-clocks'),
    }
    def scratch_focus(self, name):
        wanted = self.scratch_focus_ids[name]
        t = self.i3.get_tree()
        if s := t.scratchpad():
            found = tuple(filter(filter_floating, wanted[0](s)))
            if len(found) > 0:
                self.i3.command(';'.join(f'[con_id={con.id}] scratchpad show, sticky enable' for con in found))
                return
        found = tuple(filter(filter_floating, wanted[0](t)))
        if len(found) > 0:
            self.i3.command(';'.join(f'[con_id={con.id}] move scratchpad' for con in found))
            skip_taskbar(self.ipc_grp.dpy(), (c.window for c in found))
            return
        self.i3.command(wanted[1])
    # }}}
    # Launch/kill floating window {{{
    launch_or_kill_ids = {
        'audio_control': (lambda c: c.find_instanced(r'^pavucontrol$'),
                         'exec pavucontrol'),
        'network_control': (lambda c: c.find_instanced(r'^nm-connection-editor$'),
                         'exec nm-connection-editor'),
        'bt_control': (lambda c: c.find_instanced(r'^blueman-manager$'),
                         'exec blueman-manager')
    }
    def launch_or_kill(self, name):
        wanted = self.launch_or_kill_ids[name]
        t = self.i3.get_tree()
        found = tuple(filter(filter_floating, wanted[0](t)))
        if len(found) > 0:
            self.i3.command(';'.join(f'[con_id={con.id}] kill' for con in found))
            return
        self.i3.command(wanted[1])
    # }}}
# }}}
# Move marked window {{{
MOVE_MARK = re.compile(r'^move:(.+)')


class MarkedWindowMoveHandler(i3SignalHandler):
    event = Event.WINDOW_MARK
    def handler(self, i3, e):
        for mark in e.container.marks:
            if m := MOVE_MARK.match(mark):
                i3.command(f'[con_id={e.container.id}] move container to workspace {find_ws(i3.get_workspaces(), postfix=m.groups()[0])}, focus, unmark {mark}')
                break
# }}}
# }}}
# Main {{{
if __name__ == '__main__':
    gbulb.install(gtk=False)
    DBusGMainLoop(set_as_default=True)

    special_ws = SpecialWorkspaceHandler()
    du = DesktopUtility(SignalHandlerGroup(
        special_ws,
        KeybindingsHandler(special_ws),
        MarkedWindowMoveHandler(),
        ScreensaverHandler()
    ))

    loop = gbulb.get_event_loop()
    loop.add_signal_handler(signal.SIGINT, loop.stop)
    loop.add_signal_handler(signal.SIGTERM, loop.stop)
    du.run(loop)
# }}}
# vim: set foldmethod=marker foldmarker={{{,}}}:
