#!/usr/bin/env python3
# Imports {{{
import signal
import os
from i3ipc import Connection, Event
import gbulb
import dbus
from dbus.mainloop.glib import DBusGMainLoop
from enum import Enum
import re
# }}}
# Model {{{
class SignalHandler:
    def __init__(self):
        self._parent = None

    def register(self, ipc_grp):
        self.ipc_grp = ipc_grp

    def unregister(self):
        ...


class MultiHandler(SignalHandler):
    def __init__(self, init):
        super().__init__()
        init._parent = self
        self.handlers = [init]

    def register(self, ipc_grp):
        super().register(ipc_grp)
        for h in handlers:
            h.ipc_grp = ipc_grp

    def handler(self, *args, **kwargs):
        for h in reversed(handlers):
            h.handler(*args, **kwargs)

    def push(self, handler):
        handler._parent = self
        handler.ipc_grp = self.ipc_grp
        self.handlers.append(handler)

    def pop(self):
        handler = self.handlers.pop(-1)
        handler._parent = None
        handler.ipc_grp = None


DBusBus = Enum('DBusBus', ('SYSTEM', 'SESSION'))


class DBusSignalHandler(SignalHandler):
    def __init__(self):
        super().__init__()

    def register(self, ipc_grp):
        super().register(ipc_grp)
        if self.bus == DBusBus.SYSTEM:
            bus = ipc_grp.d_sys()
        elif self.bus == DBusBus.SESSION:
            bus = ipc_grp.d_ses()
        bus.add_signal_receiver(self.handler, **self.dbus_kwargs)


class i3SignalHandler(SignalHandler):
    def __init__(self):
        super().__init__()

    def register(self, ipc_grp):
        super().register(ipc_grp)
        ipc_grp.i3().on(self.event, self.handler)


class i3MultiHandler(MultiHandler):
    def __init__(self):
        super().__init__()

    def register(self, ipc_grp):
        super().register(ipc_grp)
        ipc_grp.i3().on(self.event, self.handler)


NOP_CMD_ARG = re.compile(r'.*nop ([^;, ]*) ?([^;,]*)(;|,|$)')


class i3BindHandler(i3SignalHandler):
    event = Event.BINDING
    def __init__(self):
        super().__init__()

    def handler(self, i3, e):
        if len(e.binding.command) > 4 and e.binding.command[0] == 'n' \
        and e.binding.command[1] == 'o' and e.binding.command[2] == 'p':
            if m := NOP_CMD_ARG.match(e.binding.command):
                cmd = m.groups()
                if f := getattr(self, cmd[0], None):
                    if len(cmd[1]) == 0:
                        f()
                    else:
                        f(*cmd[1].split(' '))


class IPCGroup:
    def __init__(self):
        self._i3 = None
        self._d_sys = None
        self._d_ses = None

    def i3(self):
        if self._i3 is None:
            self._i3 = Connection()
        return self._i3

    def pre_loop(self, loop):
        self._loop = loop
        if self._i3:
            self._i3._event_socket_setup()
            loop.add_reader(self._i3._sub_socket, self._i3._event_socket_poll)

    def post_loop(self):
        if self._i3:
            self._i3._event_socket_teardown()

    def d_sys(self):
        if self._d_sys is None:
            self._d_sys = dbus.SystemBus()
        return self._d_sys

    def d_ses(self):
        if self._d_ses is None:
            self._d_ses = dbus.SessionBus()
        return self._d_ses

    def quit(self):
        self._loop.stop()


class SignalHandlerGroup:
    def __init__(self, *handlers):
        self.handlers = handlers

    def register(self, ipc_grp):
        for handler in self.handlers:
            handler.register(ipc_grp)


class DesktopUtility:
    def __init__(self, sh_grp):
        self.sh_grp = sh_grp

    def run(self, loop):
        self._loop = loop
        self.ipc_grp = IPCGroup()
        self.sh_grp.register(self.ipc_grp)
        self.ipc_grp.pre_loop(loop)
        try:
            self._loop.run_forever()
        finally:
            self.ipc_grp.post_loop()
            self._loop.close()
# }}}
# Helper functions {{{
def find_ws(i3_ws, postfix=None, reverse=False):
    all_ws = {1,2,3,4,5,6,7,8,9,10}
    for ws in i3_ws:
        if postfix is not None and postfix in ws.name:
            return ws.name
        all_ws.discard(ws.num)
    if reverse:
        new_ws = str(max(all_ws))
    else:
        new_ws = str(min(all_ws))
    if postfix is not None:
        new_ws += ':' + postfix
    return new_ws
# }}}
# Handlers {{{
# Screensaver {{{
class ScreensaverHandler(DBusSignalHandler):
    def __init__(self):
        super().__init__()

    bus = DBusBus.SESSION
    dbus_kwargs = {'dbus_interface': 'org.mate.ScreenSaver'}

    def handler(self, state, *args, **kwargs):
        if state == 1:
            os.system('dunstctl set-paused true')
        elif state == 0:
            os.system('dunstctl set-paused false')
# }}}
# Special workspace {{{
class SpecialWorkspaceHandler(i3SignalHandler):
    def __init__(self):
        super().__init__()

    event = Event.WORKSPACE_FOCUS
    launchers = {
        'b': 'exec --no-startup-id exec $HOME/.i3/chatrc',
        'e': 'exec --no-startup-id exec $HOME/.i3/mailrc',
        'g': 'exec --no-startup-id exec $HOME/.i3/officerc',
        't': 'exec --no-startup-id exec $TERMINAL',
        'w': 'exec --no-startup-id exec $HOME/.i3/webrc',
        'y': 'exec --no-startup-id exec $HOME/.i3/mediarc',
        'z': 'exec --no-startup-id exec $HOME/.i3/gamerc'
    }

    def get_launcher(self, ws, override=False):
        if ws.name[0] in self.launchers:
            launcher = self.launchers[ws.name[0]]
            if override:
                return launcher
            for _ in ws:
                return None
            return launcher
        return None

    def handler(self, i3, e):
        if launcher := self.get_launcher(e.current):
            for ws in i3.get_workspaces():
                if ws.focused and ws.name != e.current.name:
                    return
            i3.command(launcher)
# }}}
# Keybindings {{{
class KeybindingsHandler(i3BindHandler):
    def __init__(self, special_ws):
        super().__init__()
        self.special_ws = special_ws

    def launch_this(self):
        i3 = self.ipc_grp.i3()
        for ws in i3.get_workspaces():
            if ws.focused:
                if launcher := special_ws.get_launcher(ws, True):
                    i3.command(launcher)
                    break

    def blank_ws(self, *args):
        reverse = len(args) > 0 and '--reverse' in args
        move = len(args) > 0 and '--move' in args
        i3 = self.ipc_grp.i3()
        new_ws = find_ws(i3.get_workspaces(), reverse=reverse)
        if move:
            i3.command(f'move container to workspace number {new_ws};workspace number {new_ws}')
        else:
            i3.command(f'workspace number {new_ws}')
# }}}
# Move marked window {{{
MOVE_MARK = re.compile(r'^move:(.+)')


class MarkedWindowMoveHandler(i3SignalHandler):
    event = Event.WINDOW_MARK
    def handler(self, i3, e):
        for mark in e.container.marks:
            if m := MOVE_MARK.match(mark):
                i3.command(f'[con_id={e.container.id}] move container to workspace {find_ws(i3.get_workspaces(), postfix=m.groups()[0])}, focus, unmark {mark}')
                break
# }}}
# }}}
# Main {{{
if __name__ == '__main__':
    gbulb.install(gtk=False)
    DBusGMainLoop(set_as_default=True)

    special_ws = SpecialWorkspaceHandler()
    du = DesktopUtility(SignalHandlerGroup(
        special_ws,
        KeybindingsHandler(special_ws),
        MarkedWindowMoveHandler(),
        ScreensaverHandler()
    ))

    loop = gbulb.get_event_loop()
    loop.add_signal_handler(signal.SIGINT, loop.stop)
    loop.add_signal_handler(signal.SIGTERM, loop.stop)
    du.run(loop)
# }}}
# vim: set foldmethod=marker foldmarker={{{,}}}:
